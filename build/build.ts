// 在当前文件，给我用Babel写个东西，它能取出给定文件中三斜杠注释/// #declaration:global到/// #enddeclaration之间的内容
// 然后对于每个类型定义（不会输出到JS的)，如果有export前缀，去除export，没有则不动；
// 对于每个会输出到JS的常量、类、函数、，枚举，如果有export，去除export，没有则移除这些定义

// 最后把所有内容输出到一个declaration.g.d.ts文件

import { parse } from '@babel/parser';
import traverse from "@babel/traverse";
import { hash } from 'bun';
import { rename, exists, rm, cp } from "fs/promises";
import { basename, join, relative } from "path";
import util from 'util';

type DeclarationType = 'global' | 'local';

interface DeclarationBlock {
  content: string;
  type: DeclarationType;
}

/**
 * 提取文件中三斜杠注释块的内容
 * @param filePath 文件路径
 * @returns 提取的注释块列表
 */
// 修改为异步函数
async function extractDeclarationBlocks(filePath: string): Promise<DeclarationBlock[]> {
  // 使用 Bun.file 读取文件内容 (改为异步)
  const fileContent = await Bun.file(filePath).text();
  const blocks: DeclarationBlock[] = [];
  const regex = /\/\/\/ #declaration:(global|local)([\s\S]*?)\/\/\/ #enddeclaration/g;
  let match;

  while ((match = regex.exec(fileContent)) !== null) {
    blocks.push({
      type: match[1] as DeclarationType,
      content: match[2].trim(),
    });
  }

  return blocks;
}

util.inspect.defaultOptions.depth = 50;


/**
 * 处理类型定义和输出内容
 * @param content 原始内容
 * @returns 处理后的内容
 */
function processContent(content: string): string {
  // 使用 Babel 解析 TypeScript 代码
  const ast = parse(content, {
    sourceType: "module",
    plugins: ["typescript"]
  });
  Bun.write("ast" + hash(content), util.format(ast));
  console.log(content.substring(0, 40), hash(content))

  // 存储需要保留和修改的代码段
  const codeSegments: { start: number; end: number; newText?: string }[] = [];
  
  // 遍历 AST 节点，识别各种声明类型
  traverse(ast, {
    ExportNamedDeclaration(path) {
      const node = path.node;
      const start = node.start ?? 0;
      const end = node.end ?? 0;
      
      // 处理 export { ... } 语句
      if (node.declaration === null && node.specifiers.length > 0) {
        // 移除非类型导入/导出
        codeSegments.push({ start, end, newText: "" });
      } else if (node.declaration) {
        // 有具体声明的导出，移除export关键字，保留声明部分
        const declarationStart = node.declaration.start ?? 0;
        codeSegments.push({
          start,
          end: declarationStart,
          newText: ""
        });
      }
    },
    ExportDefaultDeclaration(path) {
      const node = path.node;
      const start = node.start ?? 0;
      const end = node.end ?? 0;
      
      // 移除默认导出
      codeSegments.push({ start, end, newText: "" });
    },
    // 添加处理没有export的声明
    VariableDeclaration(path) {
      // 检查是否是export的变量声明
      if (!path.parentPath.isExportDeclaration() && path.parentPath.isProgram()) {
        // 删除没有export前缀的变量声明
        const node = path.node;
        const start = node.start ?? 0;
        const end = node.end ?? 0;
        codeSegments.push({ start, end, newText: "" });
      }
    },
    FunctionDeclaration(path) {
      // 检查是否是export的函数声明
      if (!path.parentPath.isExportDeclaration() && path.parentPath.isProgram()) {
        // 删除没有export前缀的函数声明
        const node = path.node;
        const start = node.start ?? 0;
        const end = node.end ?? 0;
        codeSegments.push({ start, end, newText: "" });
      }
    },
    ClassDeclaration(path) {
      // 检查是否是export的类声明
      if (!path.parentPath.isExportDeclaration() && path.parentPath.isProgram()) {
        // 删除没有export前缀的类声明
        const node = path.node;
        const start = node.start ?? 0;
        const end = node.end ?? 0;
        codeSegments.push({ start, end, newText: "" });
      }
    },
    TSEnumDeclaration(path) {
      // 检查是否是export的枚举声明
      if (!path.parentPath.isExportDeclaration() && path.parentPath.isProgram()) {
        // 删除没有export前缀的枚举声明
        const node = path.node;
        const start = node.start ?? 0;
        const end = node.end ?? 0;
        codeSegments.push({ start, end, newText: "" });
      }
    },
    // 处理类型定义相关节点
    TSInterfaceDeclaration(path) {
      // 接口声明不需要处理，保留原样
    },
    TSTypeAliasDeclaration(path) {
      // 类型别名不需要处理，保留原样
    }
  });

  // 应用代码修改
  let result = content;
  // 从后往前应用修改，避免位置偏移
  codeSegments.sort((a, b) => b.start - a.start);
  
  for (const segment of codeSegments) {
    if (segment.newText !== undefined) {
      result = result.substring(0, segment.start) + segment.newText + result.substring(segment.end);
    } else {
      result = result.substring(0, segment.start) + result.substring(segment.end);
    }
  }

  return result;
}

/**
 * 主函数
 * @param inputFiles 输入文件路径数组
 * @param outputFile 输出文件路径
 */
// 修改为异步函数
async function main(inputFiles: string[], outputFile: string) {
  let outputContent = '// Generated by extract-declarations tool\n\n';

  // 遍历所有输入文件
  for (const inputFile of inputFiles) {
    // 等待异步函数完成
    const blocks = await extractDeclarationBlocks(inputFile);
    
    for (const block of blocks) {
      const processedContent = processContent(block.content);
      outputContent += `// ${block.type} declarations\n${processedContent}\n\n`;
    }
  }

  // 使用 Bun.write 写入文件
  await Bun.write(outputFile, outputContent);
  console.log(`Declarations extracted to ${outputFile}`);
}

const inputFiles = [
    "src/chart.ts", "src/easing.ts", "src/util.ts", "src/time.ts", "src/bpm.ts", "src/chartTypes.ts", "src/jumparray.ts", "src/event.ts",
    "src/note.ts", "src/judgeline.ts", "src/evaluator.ts", "src/version.ts", "src/rpeChartCompiler.ts", "src/env.ts"
]

await main(inputFiles, "dist/declaration.g.ts")

Bun.spawnSync(["tsc", "--declaration", "--emitDeclarationOnly", "dist/declaration.g.ts", "--outFile", "dist/declaration.g.d.ts"], {
    stdio: ["inherit", "inherit", "inherit"]
});

Bun.spawnSync(["tsc", "--declaration", "--emitDeclarationOnly", "src/index.ts", "--outFile", "dist/index.d.ts"], {
    stdio: ["inherit", "inherit", "inherit"]
});

// 把index.d.ts里面的declare module "index"改成declare module "kipphi"
Bun.write(
  "dist/declaration.g.d.ts",
  await Bun.file("dist/declaration.g.d.ts").text()
        .then(text => text.replace(/declare module "index"/g, "declare module \"kipphi\""))
);



Bun.build({
  entrypoints: ["src/index.ts"],
  outdir: "dist/",
  naming: "index.js",
  format: "esm"
});

Bun.build({
  entrypoints: ["build/global.ts"],
  outdir: "dist/",
  naming: "forglobal.js",
  format: "cjs"
})


// 完事以后把.g.ts扩展名去掉，这样不会和d.ts冲突
// 如果已有一个dist/declaration（不带扩展名），需要强制替换
// 先检查dist/declaration是否存在
if (await exists("dist/declaration")) {
    await rm("dist/declaration");
    await rename("dist/declaration.g.ts", "dist/declaration");
} else {
    await rename("dist/declaration.g.ts", "dist/declaration");
}

const glob = new Bun.Glob("src/**/*");
for await (const file of glob.scan(".")) {
  console.log(file);
  const fileName = relative("src", file)
  if (fileName) {
    await cp(file, `packages/package-kipphi/${fileName}`);
  }
}


await cp("src/index.ts", "packages/package-kipphi/index.ts")
await cp("dist/index.js", "packages/package-kipphi/index.js")
await cp("dist/index.d.ts", "packages/package-kipphi/index.d.ts")

await cp("README.md", "packages/package-kipphi/README.md")
await cp("LICENSE", "packages/package-kipphi/LICENSE")
// 其他复制操作保持不变
await cp("dist/declaration.g.d.ts", "packages/package-kipphi-global/index.d.ts");
await cp("dist/forglobal.js", "packages/package-kipphi-global/index.js");
await cp("dist/declaration.g.d.ts", "packages/package-kipphi-global/declaration.g.d.ts");
await cp("dist/declaration.g.d.ts", "packages/package-kipphi-global/index.d.ts");
await cp("dist/forglobal.js", "packages/package-kipphi-global/index.js");
await cp("dist/declaration.g.d.ts", "packages/package-kipphi-global/declaration.g.d.ts");
await cp("LICENSE", "packages/package-kipphi-global/LICENSE");
await cp("README.md", "packages/package-kipphi-global/README.md");
// 示例用法
// await main(['path/to/input/file1.ts', 'path/to/input/file2.ts'], 'path/to/output/declaration.g.d.ts');